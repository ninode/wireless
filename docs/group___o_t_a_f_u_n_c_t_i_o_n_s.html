<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.8.15"/>
  <title>Wireless - Harmony 3: Functions</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="customstylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
 <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
 <div id="titlearea">
 <table cellspacing="0" cellpadding="0">
 <tbody>
   <tr style="height: 56px;vertical-align: text-bottom;">
    <td style="padding: 0.2em 0.5em 0.1em 0.5em;">
	  <a id="projectlogo"><img alt="Logo" src="Microchip_logo.png"/> </a> </td>
     <td style="padding-right: 1em;">
       <span id="projectname"/> <class="stringliteral">Wireless - Harmony 3 </span>
     </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group___o_t_a_a_p_i.html">OTA</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lists the full set of available APIs to manage OTA updates and Host File Downloads.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga08275ebf9834c5223311bc8ae9627959"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> (<a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> pfOtaUpdateCb, <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga794a38a7732c4c11ea0ca8081dbd6300">tpfOtaNotifCb</a> pfOtaNotifCb, <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gae1cb62be5a842f4d1343b4076ddc37c7">tpfFileGetCb</a> pfHFDGetCb)</td></tr>
<tr class="separator:ga08275ebf9834c5223311bc8ae9627959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347bfe1c0c505f6aa9555efc8b701b0c"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga347bfe1c0c505f6aa9555efc8b701b0c">m2m_ota_notif_set_url</a> (uint8_t *u8Url)</td></tr>
<tr class="memdesc:ga347bfe1c0c505f6aa9555efc8b701b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the OTA url.  <a href="#ga347bfe1c0c505f6aa9555efc8b701b0c">More...</a><br /></td></tr>
<tr class="separator:ga347bfe1c0c505f6aa9555efc8b701b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a3b76022a3606acc2369ad7b1ab9a5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gab0a3b76022a3606acc2369ad7b1ab9a5">m2m_ota_notif_check_for_update</a> (void)</td></tr>
<tr class="memdesc:gab0a3b76022a3606acc2369ad7b1ab9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">check for ota update  <a href="#gab0a3b76022a3606acc2369ad7b1ab9a5">More...</a><br /></td></tr>
<tr class="separator:gab0a3b76022a3606acc2369ad7b1ab9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420f4a1c3f2868bd63c4118f00e55103"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga420f4a1c3f2868bd63c4118f00e55103">m2m_ota_notif_sched</a> (uint32_t u32Period)</td></tr>
<tr class="memdesc:ga420f4a1c3f2868bd63c4118f00e55103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule OTA update.  <a href="#ga420f4a1c3f2868bd63c4118f00e55103">More...</a><br /></td></tr>
<tr class="separator:ga420f4a1c3f2868bd63c4118f00e55103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38a82b1bc3c43d3e48f8c4956b191ab1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a> (uint8_t *u8DownloadUrl)</td></tr>
<tr class="separator:ga38a82b1bc3c43d3e48f8c4956b191ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad238a0b0d9218b8db10d82a95fc91dad"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a> (void)</td></tr>
<tr class="memdesc:gad238a0b0d9218b8db10d82a95fc91dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request OTA Rollback image.  <a href="#gad238a0b0d9218b8db10d82a95fc91dad">More...</a><br /></td></tr>
<tr class="separator:gad238a0b0d9218b8db10d82a95fc91dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4a8242b07c4d0b6532c23cba971769"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gade4a8242b07c4d0b6532c23cba971769">m2m_ota_abort</a> (void)</td></tr>
<tr class="memdesc:gade4a8242b07c4d0b6532c23cba971769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request OTA Abort.  <a href="#gade4a8242b07c4d0b6532c23cba971769">More...</a><br /></td></tr>
<tr class="separator:gade4a8242b07c4d0b6532c23cba971769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e44fbce7ca42ded0e1daa500c40ca8"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a> (void)</td></tr>
<tr class="memdesc:ga24e44fbce7ca42ded0e1daa500c40ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to the upgraded Firmware.  <a href="#ga24e44fbce7ca42ded0e1daa500c40ca8">More...</a><br /></td></tr>
<tr class="separator:ga24e44fbce7ca42ded0e1daa500c40ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874929fdb3fed8bdf01a740bf4bf4beb"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga874929fdb3fed8bdf01a740bf4bf4beb">m2m_ota_host_file_get</a> (char *pcDownloadUrl, <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gae1cb62be5a842f4d1343b4076ddc37c7">tpfFileGetCb</a> pfHFDGetCb)</td></tr>
<tr class="memdesc:ga874929fdb3fed8bdf01a740bf4bf4beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download a file from a remote location and store it in the WINC's Flash.  <a href="#ga874929fdb3fed8bdf01a740bf4bf4beb">More...</a><br /></td></tr>
<tr class="separator:ga874929fdb3fed8bdf01a740bf4bf4beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab307c3df5ce842c492699de8e41a3ce6"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gab307c3df5ce842c492699de8e41a3ce6">m2m_ota_host_file_read_hif</a> (uint8_t u8Handler, uint32_t u32Offset, uint32_t u32Size, <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga133615f1d378278533dfbee06164b18c">tpfFileReadCb</a> pfHFDReadCb)</td></tr>
<tr class="memdesc:gab307c3df5ce842c492699de8e41a3ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a certain amount of bytes from a file in WINC's Flash using HIF transfer.  <a href="#gab307c3df5ce842c492699de8e41a3ce6">More...</a><br /></td></tr>
<tr class="separator:gab307c3df5ce842c492699de8e41a3ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab042e0aead4ac016b1ca7ac61a70badc"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gab042e0aead4ac016b1ca7ac61a70badc">m2m_ota_host_file_read_spi</a> (uint8_t u8Handler, uint8_t *pu8Buff, uint32_t u32Offset, uint32_t u32Size)</td></tr>
<tr class="memdesc:gab042e0aead4ac016b1ca7ac61a70badc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a certain amount of bytes from a file in WINC's Flash using SPI transfer.  <a href="#gab042e0aead4ac016b1ca7ac61a70badc">More...</a><br /></td></tr>
<tr class="separator:gab042e0aead4ac016b1ca7ac61a70badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f9dd4fe52068bee290bed98213701e2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga7f9dd4fe52068bee290bed98213701e2">m2m_ota_host_file_erase</a> (uint8_t u8Handler, <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga285bca5ad40e2de76fcafbaa76657ee9">tpfFileEraseCb</a> pfHFDEraseCb)</td></tr>
<tr class="memdesc:ga7f9dd4fe52068bee290bed98213701e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase any traces of an existing file, this means from host driver and WINC firmware.  <a href="#ga7f9dd4fe52068bee290bed98213701e2">More...</a><br /></td></tr>
<tr class="separator:ga7f9dd4fe52068bee290bed98213701e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80058af2f37ab262dbc1b5f5327708f7"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga80058af2f37ab262dbc1b5f5327708f7">m2m_ota_init</a> (<a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> pfOtaUpdateCb)</td></tr>
<tr class="memdesc:ga80058af2f37ab262dbc1b5f5327708f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the OTA layer.  <a href="#ga80058af2f37ab262dbc1b5f5327708f7">More...</a><br /></td></tr>
<tr class="separator:ga80058af2f37ab262dbc1b5f5327708f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefb92e6e53637bd62b8371e7f00dd4eb"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gaefb92e6e53637bd62b8371e7f00dd4eb">m2m_ota_start_update</a> (unsigned char *pcDownloadUrl)</td></tr>
<tr class="memdesc:gaefb92e6e53637bd62b8371e7f00dd4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request OTA start update using the downloaded URL.  <a href="#gaefb92e6e53637bd62b8371e7f00dd4eb">More...</a><br /></td></tr>
<tr class="separator:gaefb92e6e53637bd62b8371e7f00dd4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Lists the full set of available APIs to manage OTA updates and Host File Downloads. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gade4a8242b07c4d0b6532c23cba971769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade4a8242b07c4d0b6532c23cba971769">&#9670;&nbsp;</a></span>m2m_ota_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request OTA Abort. </p>
<p>Request the WINC to abort an OTA or Host File download in progress.<br />
 If no download is in progress, the API will respond with failure.</p>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd>
<dd>
The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operation and a negative value otherwise.</dd>
<dd>
The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<p>Abort an ota in progress (eg if server has stalled) and clean up </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga80058af2f37ab262dbc1b5f5327708f7" title="Initialize the OTA layer.">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga7f9dd4fe52068bee290bed98213701e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f9dd4fe52068bee290bed98213701e2">&#9670;&nbsp;</a></span>m2m_ota_host_file_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_host_file_erase </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga285bca5ad40e2de76fcafbaa76657ee9">tpfFileEraseCb</a>&#160;</td>
          <td class="paramname"><em>pfHFDEraseCb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase any traces of an existing file, this means from host driver and WINC firmware. </p>
<p>Erase any traces of file stored in WINC's Flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Handler</td><td>ID of the file we are trying to erase. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHFDEraseCb</td><td>Pointer to callback to execute when the file erase in the WINC completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the erase operation</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Providing a callback is optional. If the current handler is invalid at this point, it means one of the three:<ol type="1">
<li>The file never existed;</li>
<li>The file has already been already deleted;</li>
<li>The request to get the file hasn't fully completed. For 1. and 2. there is no need to signal the WINC to erase the file in Flash. For 3. the Flash can't be erased while a file download is ongoing.</li>
</ol>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This functionality is only supported from WINC release 19.6.0 onwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Handler</td><td>Handler of the file we are trying to erase. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHFDEraseCb</td><td>Pointer to callback (see <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga285bca5ad40e2de76fcafbaa76657ee9">tpfFileEraseCb</a>) to execute when the file erase is completed by the WINC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>In order to execute the callback, <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> must be called before requesting the erase.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Providing a callback is optional. If the current handler is invalid at this point, it means one of the three:<ol type="1">
<li>The file never existed;</li>
<li>The file has already been already deleted;</li>
<li>The request to get the file hasn't fully completed. </li>
</ol>
</dd></dl>
<dl class="section user"><dt></dt><dd>For 1. and 2. there is no need to signal the WINC to erase the file in Flash.<br />
 For 3. the Flash can't be erased while a file download is ongoing.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A valid file handler must be provided, this means that it needs to match the handler internally stored by the WINC and must not be HFD_INVALID_HANDLER.<br />
 The handlers will be destroyed regardless of the call returning success or not.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga874929fdb3fed8bdf01a740bf4bf4beb" title="Download a file from a remote location and store it in the WINC&#39;s Flash.">m2m_ota_host_file_get</a> </dd></dl>

</div>
</div>
<a id="ga874929fdb3fed8bdf01a740bf4bf4beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga874929fdb3fed8bdf01a740bf4bf4beb">&#9670;&nbsp;</a></span>m2m_ota_host_file_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_host_file_get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcDownloadUrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gae1cb62be5a842f4d1343b4076ddc37c7">tpfFileGetCb</a>&#160;</td>
          <td class="paramname"><em>pfHFDGetCb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Download a file from a remote location and store it in the WINC's Flash. </p>
<p>Download a file from a remote location and store it in WINC's Flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcDownloadUrl</td><td>Url pointing to the remote file. HTTP/HTTPS only.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHFDGetCb</td><td>Pointer to a callback to be executed when the download finishes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the get operation</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>1. Providing a callback is mandatory.<ol type="1">
<li>This functionality is only supported from WINC release 19.6.0 onwards.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcDownloadUrl</td><td>Url pointing to the remote file. HTTP/HTTPS only.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHFDGetCb</td><td>Pointer to a callback (see <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gae1cb62be5a842f4d1343b4076ddc37c7">tpfFileGetCb</a>) to be executed when the download finishes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> to be called before a download can start.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This functionality is only supported from WINC release 19.6.1 onwards. The maximum file size that can be stored in WINC1510 is 508KB, the WINC1500 variant is not supported for Host File Download.<br />
 Concurrent use of Host File Get and WINC OTA is not possible.<br />
 Providing a callback is mandatory.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga874d3f514a02885338526f106a5f260d" title="A callback to notify the application of the result of the download (success/fail),...">tpfFileGetCb</a> </dd></dl>

</div>
</div>
<a id="gab307c3df5ce842c492699de8e41a3ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab307c3df5ce842c492699de8e41a3ce6">&#9670;&nbsp;</a></span>m2m_ota_host_file_read_hif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_host_file_read_hif </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga133615f1d378278533dfbee06164b18c">tpfFileReadCb</a>&#160;</td>
          <td class="paramname"><em>pfHFDReadCb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a certain amount of bytes from a file in WINC's Flash using HIF transfer. </p>
<p>Read a certain amount of bytes from a file previously stored in WINC's Flash using HIF transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Handler</td><td>ID of the file we are trying to read from. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Offset</td><td>Offset from start of the file to read from (in bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Size</td><td>The amount of data to read (in bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHFDReadCb</td><td>Callback to be executed when the read operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the read operation</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>1. Providing a callback is mandatory.<ol type="1">
<li>This functionality is only supported from WINC release 19.6.0 onwards.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Handler</td><td>Handler of the file we are trying to read from. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Offset</td><td>Offset from start of the file to read from (in bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Size</td><td>The amount of data to read (in bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfHFDReadCb</td><td>Callback (see <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga133615f1d378278533dfbee06164b18c">tpfFileReadCb</a>) to be executed when the read operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Requires <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> to be called before a read via HIF can be requested.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>There is a limitation on how much data can be transferred at a time using HIF read, which is 128 bytes. The limitation described above can potentially reduce the speed of the read due to extra overhead, but using the HIF is non-blocking and therefore the Application can continue execution as normal, being interrupted only when data is available. Another advantage is that it does not require the WINC to be reset or put in download mode, as it is the case for reading the file via SPI (see <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gab042e0aead4ac016b1ca7ac61a70badc">m2m_ota_host_file_read_spi</a>).<br />
 A valid file handler must be provided, this means that it needs to match the handler internally stored by the WINC and must not be HFD_INVALID_HANDLER.<br />
 Providing a callback is mandatory.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When calling this API while specifying a size &gt; 128 bytes, the read will be limited to the first 128 bytes starting at the read offset. It it recommended that a read for sizes above 128 bytes is performed in multiple steps, using the callback to advance the offset and request another read of 128 bytes (or less) each time.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga874929fdb3fed8bdf01a740bf4bf4beb" title="Download a file from a remote location and store it in the WINC&#39;s Flash.">m2m_ota_host_file_get</a> <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gae30db97b97442680ebb51caac0659da4" title="A callback to handle a buffer of data after requesting a Host File read. The callback will provide th...">tpfFileReadCb</a> </dd></dl>

</div>
</div>
<a id="gab042e0aead4ac016b1ca7ac61a70badc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab042e0aead4ac016b1ca7ac61a70badc">&#9670;&nbsp;</a></span>m2m_ota_host_file_read_spi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_host_file_read_spi </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pu8Buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a certain amount of bytes from a file in WINC's Flash using SPI transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Handler</td><td>ID of the file we are trying to read from. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8Buff</td><td>Pointer to a buffer to store the data being read. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Offset</td><td>Offset from start of the file to read from (in bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Size</td><td>The amount of data to read (in Bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the read operation</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>1. Before using m2m_ota_host_file_read_spi, the WINC needs to be put in a special mode to allow for a safe access to the Flash. This can be done by calling <a class="el" href="group___w_l_a_n_a_p_i.html#ga1dfd77b592cbe00ce1f8576178f40ec6">m2m_wifi_download_mode</a> or <a class="el" href="group___w_l_a_n_a_p_i.html#ga898370c1b6dc5e7c0f68cd9f9fda0880">m2m_wifi_reinit_hold</a> before trying to read.</dd></dl>
<ol type="1">
<li>This functionality is only supported from WINC release 19.6.0 onwards.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Handler</td><td>Handler of the file we are trying to read from. Must be valid.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pu8Buff</td><td>Pointer to a buffer to store the data being read. Must not be NULL.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Offset</td><td>Offset from start of the file to read from (in bytes).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Size</td><td>The amount of data to read (in Bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Reading of a file via SPI can be much faster than by reading it via the HIF. However, the read will be blocking and it will require the WINC to be put into download mode prior to the read, the download mode means that the WINC will act as Flash device and not as a Wifi device. So, before using m2m_ota_host_file_read_spi, the Application should call <a class="el" href="group___w_l_a_n_a_p_i.html#ga1dfd77b592cbe00ce1f8576178f40ec6">m2m_wifi_download_mode</a> before trying to read. After the read finishes, the WINC needs to be reset (see <a class="el" href="group___w_l_a_n_a_p_i.html#ga8bf2241d88a498ff1f94614064505d47">m2m_wifi_reinit</a>).<br />
 A valid file handler must be provided, this means that it needs to match the handler internally stored by the WINC and must not be <a class="el" href="group___o_t_a_d_e_f_i_n_e.html#gabee73a5cfde46a8918274961bc43dc32">HFD_INVALID_HANDLER</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga874929fdb3fed8bdf01a740bf4bf4beb" title="Download a file from a remote location and store it in the WINC&#39;s Flash.">m2m_ota_host_file_get</a></dd></dl>
<h1><a class="anchor" id="Host"></a>
File Download SPI Read Example</h1>
<p>The following is an example of how to perform a read file from the WINC via SPI. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    uint8_t u8Handler;</div><div class="line">    uint32_t u32Offset;</div><div class="line">    uint32_t u32Size;</div><div class="line">    uint8_t au8Buff[200];</div><div class="line">}FileDescriptor;</div><div class="line"></div><div class="line"><a class="code" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> gstrWifiParam;</div><div class="line"><span class="keyword">static</span> FileDescriptor gstrAppFile;</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> *acURL = <span class="stringliteral">&quot;http://www.microchip.com/_images/ics/medium-ATWINC1500-MODULE-28.png&quot;</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ReadFileSPI(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> wifi_event_cb(uint8_t u8WiFiEvent, <span class="keywordtype">void</span> * pvMsg);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> FileGetCallback(uint8_t u8Status, uint8_t u8Handler, uint32_t u32Size);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> OtaUpdateCb(uint8_t u8OtaUpdateStatusType ,uint8_t u8OtaUpdateStatus);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> wifi_event_cb(uint8_t u8WiFiEvent, <span class="keywordtype">void</span> * pvMsg)</div><div class="line">{</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___wlan_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a>:</div><div class="line">    {</div><div class="line">        <span class="comment">// After successfully connection, start the File Download</span></div><div class="line">        gstrAppFile.u32Offset = 0;</div><div class="line">        s8Ret = <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga874929fdb3fed8bdf01a740bf4bf4beb">m2m_ota_host_file_get</a>(acURL, FileGetCallback);</div><div class="line">        <span class="keywordflow">if</span>(s8Ret != <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___debug_defines.html#ga34d005df494e50b05cd38b80f318d7ac">M2M_ERR</a>(<span class="stringliteral">&quot;File Download Failed!\n&quot;</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> OtaUpdateCb(uint8_t u8OtaUpdateStatusType ,uint8_t u8OtaUpdateStatus)</div><div class="line">{</div><div class="line">    <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;%d %d\n&quot;</span>,u8OtaUpdateStatusType,u8OtaUpdateStatus);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(u8OtaUpdateStatus == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#ggab7006b9cb55eb414d0416d0513533eeba23e293bcc679d3021e202ac255b71500">OTA_STATUS_SUCCESS</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>(u8OtaUpdateStatusType == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#gga3e56744d263918b9e36016f78d823c3aaa125479191f24a910fc75ee33de0a1d4">HFD_STATUS</a>)</div><div class="line">        {</div><div class="line">            <span class="comment">// Read the file and process it</span></div><div class="line">            ReadFileSPI();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> FileGetCallback(uint8_t u8Status, uint8_t u8Handler, uint32_t u32Size)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#ggab7006b9cb55eb414d0416d0513533eeba23e293bcc679d3021e202ac255b71500">OTA_STATUS_SUCCESS</a> == u8Status)</div><div class="line">    {</div><div class="line">        gstrAppFile.u8Handler = u8Handler;</div><div class="line">        gstrAppFile.u32Size   = u32Size;</div><div class="line">        <span class="comment">// File Get Successful</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <a class="code" href="group___debug_defines.html#ga34d005df494e50b05cd38b80f318d7ac">M2M_ERR</a>(<span class="stringliteral">&quot;File Get Failed!\n&quot;</span>);</div><div class="line">        <span class="comment">// File Get Failed</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ReadFileSPI(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    int8_t s8Ret = <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga39ed05df730834f2255971ca9879996e">M2M_ERR_FAIL</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group___wlan_enums.html#gga6fd80a986c0ee128add6160889a3b2c2a3776f24e3a21d316e8876c59352ab1f1">WIFI_STATE_DEINIT</a> != <a class="code" href="group___w_l_a_n_a_p_i.html#ga5372f7bc6a7bda4a40e0b9f979ed9a7f">m2m_wifi_get_state</a>())</div><div class="line">        <a class="code" href="group___w_l_a_n_a_p_i.html#ga13f83f33233e0e8bca691dc68b1b8d48">m2m_wifi_deinit</a>(NULL);</div><div class="line"></div><div class="line">    s8Ret = <a class="code" href="group___w_l_a_n_a_p_i.html#ga1dfd77b592cbe00ce1f8576178f40ec6">m2m_wifi_download_mode</a>();</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> != s8Ret) <span class="keywordflow">goto</span> EXIT;</div><div class="line"></div><div class="line">    <span class="comment">// gstrAppFile.u32Offset can be changed to define a starting point for the read,</span></div><div class="line">    <span class="comment">// in which case the size of the requested read should be adjusted to accommodate for this.</span></div><div class="line">    <span class="comment">// This call assumes that m2m_ota_host_file_get was called earlier, in this example it is fine</span></div><div class="line">    <span class="comment">// since ReadFileSPI is only called from the within OtaUpdateCb</span></div><div class="line">    <span class="comment">// This example simply reads the first 200 bytes of the file.</span></div><div class="line">    uint32_t u32AmountToRead = 200;</div><div class="line">    s8Ret = <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gab042e0aead4ac016b1ca7ac61a70badc">m2m_ota_host_file_read_spi</a>(gstrAppFile.u8Handler, gstrAppFile.au8Buff, gstrAppFile.u32Offset, u32AmountToRead);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> == s8Ret)</div><div class="line">        <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;\nFile Read completed, Offset: %lu, Size of Read: %lu.\n&quot;</span>, gstrAppFile.u32Offset, u32AmountToRead);</div><div class="line"></div><div class="line">    <span class="comment">// *** Do something with the contents of gstrAppFile.au8Buff ***</span></div><div class="line"></div><div class="line">    s8Ret = <a class="code" href="group___w_l_a_n_a_p_i.html#ga8bf2241d88a498ff1f94614064505d47">m2m_wifi_reinit</a>(&amp;gstrWifiParam);</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> != s8Ret) <span class="keywordflow">goto</span> EXIT;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the OTA again and reconnect to the previously connected SSID</span></div><div class="line">    <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a>(OtaUpdateCb, NULL);</div><div class="line">    <a class="code" href="group___w_l_a_n_a_p_i.html#ga739abd39f7befa0da7bcea564a726141">m2m_wifi_default_connect</a>();</div><div class="line"></div><div class="line">EXIT:</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    nm_bsp_init();</div><div class="line"></div><div class="line">    memset((uint8_t*)&amp;gstrWifiParam, 0, <span class="keyword">sizeof</span>(gstrWifiParam));</div><div class="line">    gstrWifiParam.pfAppWifiCb = wifi_event_cb;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the WINC Driver</span></div><div class="line">    int8_t s8Ret = <a class="code" href="group___w_l_a_n_a_p_i.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>(&amp;gstrWifiParam);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> != s8Ret)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___debug_defines.html#ga34d005df494e50b05cd38b80f318d7ac">M2M_ERR</a>(<span class="stringliteral">&quot;Driver Init Failed &lt;%d&gt;\n&quot;</span>,s8Ret);</div><div class="line">        <span class="keywordflow">while</span>(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the OTA module</span></div><div class="line">    <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a>(OtaUpdateCb, NULL);</div><div class="line"></div><div class="line">    <span class="comment">// *** Connect to a wifi network by calling m2m_wifi_connect() ***</span></div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1) <a class="code" href="group___w_l_a_n_a_p_i.html#ga4f0db0a89400730ce569aa9e13a3108b">m2m_wifi_handle_events</a>(NULL);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga80058af2f37ab262dbc1b5f5327708f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80058af2f37ab262dbc1b5f5327708f7">&#9670;&nbsp;</a></span>m2m_ota_init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a>&#160;</td>
          <td class="paramname"><em>pfOtaUpdateCb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the OTA layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pfOtaUpdateCb</td><td>OTA Update callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<p>Synchronous initialization function for the OTA layer by registering the update callback. Calling this API is a prerequisite for all other OTA API's. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pfOtaUpdateCb</td><td>OTA Update callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga08275ebf9834c5223311bc8ae9627959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08275ebf9834c5223311bc8ae9627959">&#9670;&nbsp;</a></span>m2m_ota_init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a>&#160;</td>
          <td class="paramname"><em>pfOtaUpdateCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#ga794a38a7732c4c11ea0ca8081dbd6300">tpfOtaNotifCb</a>&#160;</td>
          <td class="paramname"><em>pfOtaNotifCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gae1cb62be5a842f4d1343b4076ddc37c7">tpfFileGetCb</a>&#160;</td>
          <td class="paramname"><em>pfHFDGetCb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab0a3b76022a3606acc2369ad7b1ab9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a3b76022a3606acc2369ad7b1ab9a5">&#9670;&nbsp;</a></span>m2m_ota_notif_check_for_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_notif_check_for_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check for ota update </p>
<p>Synchronous function to check for the OTA update using the Notification Server URL.<br />
 Function is not implemented (not supported at the current version).</p>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Function is not implemented (not supported at the current version).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga347bfe1c0c505f6aa9555efc8b701b0c" title="Set the OTA url.">m2m_ota_notif_set_url</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga420f4a1c3f2868bd63c4118f00e55103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420f4a1c3f2868bd63c4118f00e55103">&#9670;&nbsp;</a></span>m2m_ota_notif_sched()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_notif_sched </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u32Period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule OTA update. </p>
<p>Schedule OTA notification Server check for update request after specific number of days.<br />
 Function is not implemented (not supported at the current version).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Period</td><td>Period in days</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u32Period</td><td>Period in days</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Function is not implemented (not supported at the current version).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gab0a3b76022a3606acc2369ad7b1ab9a5" title="check for ota update">m2m_ota_notif_check_for_update</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga347bfe1c0c505f6aa9555efc8b701b0c" title="Set the OTA url.">m2m_ota_notif_set_url</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga347bfe1c0c505f6aa9555efc8b701b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347bfe1c0c505f6aa9555efc8b701b0c">&#9670;&nbsp;</a></span>m2m_ota_notif_set_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_notif_set_url </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>u8Url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the OTA url. </p>
<p>Set the OTA notification server URL, the functions need to be called before any check for update.<br />
 This functionality is not supported by WINC firmware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Url</td><td>The url server address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8Url</td><td>Set the OTA notification server URL, the functions need to be called before any check for update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Prior calling of <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> is required.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Notification Server is not supported in the current version (function is not implemented).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gad238a0b0d9218b8db10d82a95fc91dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad238a0b0d9218b8db10d82a95fc91dad">&#9670;&nbsp;</a></span>m2m_ota_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_rollback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request OTA Rollback image. </p>
<p>Request OTA Roll-back to the old (inactive) WINC image, the WINC firmware will check the validity of the Roll-back image and activate it if valid. On completion, a callback of type tpfOtaUpdateCb is called (application must previously have provided the callback via m2m_ota_init). If the callback indicates successful activation, the newly-activated image will start running after next system reset.</p>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If rollback requires a host driver update in order to maintain HIF compatibility (HIF major value change), then it is recommended to update the host driver prior to calling this API.<br />
 In the event of system reset with incompatible driver/firmware, compatibility can be recovered by calling <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a> or <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga80058af2f37ab262dbc1b5f5327708f7" title="Initialize the OTA layer.">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise.</dd>
<dd>
The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<p>Request rollback to the old (inactive) WINC image. The WINC firmware will check the validity of the inactive image and activate it if it is valid. On completion, a callback of type <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> is called (application must previously have provided the callback via <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init()</a>). If the callback indicates successful activation, the newly-activated image will start running after next system reset.</p>
<dl class="section warning"><dt>Warning</dt><dd>If rollback will necessitate a host driver update in order to maintain HIF compatibility (HIF major value change), then it is recommended to update the host driver prior to calling this API. In the event of system reset with incompatible driver/firmware, compatibility can be recovered by calling <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a> or <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>. See <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#OTAExample">Example</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga80058af2f37ab262dbc1b5f5327708f7" title="Initialize the OTA layer.">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="gaefb92e6e53637bd62b8371e7f00dd4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefb92e6e53637bd62b8371e7f00dd4eb">&#9670;&nbsp;</a></span>m2m_ota_start_update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_start_update </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pcDownloadUrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request OTA start update using the downloaded URL. </p>
<p>Request OTA start update using the download URL, the OTA module will download the OTA image, ensure integrity of the image and update the validity of the image in the control structure. On completion, a callback of type <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> is called (callback previously provided via m2m_ota_init).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcDownloadUrl</td><td>The download firmware URL, you get it from device info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcDownloadUrl</td><td>The download firmware URL, according to the application server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling this API does not guarantee OTA WINC image update, it depends on the connection with the download server and the validity of the image.<br />
 Calling this API invalidates any previous valid rollback image. When the OTA succeeds, the current image will become the rollback image after <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> is a prerequisite and must have been called before using <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gaefb92e6e53637bd62b8371e7f00dd4eb">.\n</a> Switching to the newly downloaded image requires calling <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a> API.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a> <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise.</dd></dl>
<h1><a class="anchor" id="OTAExample"></a>
Example</h1>
<p>This example shows how an OTA image update and switch is carried out. It demonstrates use of the following OTA APIs: <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a> <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> OtaUpdateCb(uint8_t u8OtaUpdateStatusType ,uint8_t u8OtaUpdateStatus)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(u8OtaUpdateStatusType == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#gga3e56744d263918b9e36016f78d823c3aa9b634fb58a53969f9af8a89908e58c5e">DL_STATUS</a>) {</div><div class="line">        <span class="keywordflow">if</span>(u8OtaUpdateStatus == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#ggab7006b9cb55eb414d0416d0513533eeba23e293bcc679d3021e202ac255b71500">OTA_STATUS_SUCCESS</a>) {</div><div class="line">            <span class="comment">// Switch to the upgraded firmware</span></div><div class="line">            <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>();</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(u8OtaUpdateStatusType == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#gga3e56744d263918b9e36016f78d823c3aa2f1dabb326d861eadb5a5cd1b41962ff">SW_STATUS</a>) {</div><div class="line">        <span class="keywordflow">if</span>(u8OtaUpdateStatus == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#ggab7006b9cb55eb414d0416d0513533eeba23e293bcc679d3021e202ac255b71500">OTA_STATUS_SUCCESS</a>) {</div><div class="line">            <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;Now OTA successfully done&quot;</span>);</div><div class="line">            <span class="comment">// Start the host SW upgrade then system reset is required (Reinitialize the driver)</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> wifi_event_cb(uint8_t u8WiFiEvent, <span class="keywordtype">void</span> * pvMsg)</div><div class="line">{</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___wlan_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a>:</div><div class="line">    {</div><div class="line">        <span class="comment">//after successfully connection, start the over air upgrade</span></div><div class="line">        <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gaefb92e6e53637bd62b8371e7f00dd4eb">m2m_ota_start_update</a>(OTA_URL);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    int8_t s8Ret;</div><div class="line">    <a class="code" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a> param;</div><div class="line">    <a class="code" href="structtstr1x_auth_credentials.html">tstr1xAuthCredentials</a> gstrCred1x = AUTH_CREDENTIALS;</div><div class="line"></div><div class="line">    nm_bsp_init();</div><div class="line"></div><div class="line">    memset((uint8_t*)&amp;param, 0, <span class="keyword">sizeof</span>(param));</div><div class="line">    param.pfAppWifiCb = wifi_event_cb;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the WINC Driver</span></div><div class="line">    s8Ret = <a class="code" href="group___w_l_a_n_a_p_i.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>(&amp;param);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> != s8Ret)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___debug_defines.html#ga34d005df494e50b05cd38b80f318d7ac">M2M_ERR</a>(<span class="stringliteral">&quot;Driver Init Failed &lt;%d&gt;\n&quot;</span>,s8Ret);</div><div class="line">        <span class="keywordflow">while</span>(1);</div><div class="line">    }</div><div class="line">    <span class="comment">// Initialize the OTA module</span></div><div class="line">    <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a>(OtaUpdateCb,NULL);</div><div class="line"></div><div class="line">    <span class="comment">// Connect to AP that provide connection to the OTA server</span></div><div class="line">    <a class="code" href="group___w_l_a_n_a_p_i.html#ga739abd39f7befa0da7bcea564a726141">m2m_wifi_default_connect</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1)</div><div class="line">    {</div><div class="line">        <span class="comment">// Handle the app state machine plus the WINC event handler</span></div><div class="line">        <span class="keywordflow">while</span>(<a class="code" href="group___w_l_a_n_a_p_i.html#ga4f0db0a89400730ce569aa9e13a3108b">m2m_wifi_handle_events</a>(NULL) != <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>) {</div><div class="line"></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcDownloadUrl</td><td>The download firmware URL, you get it from device info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise. </dd></dl>

</div>
</div>
<a id="ga38a82b1bc3c43d3e48f8c4956b191ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38a82b1bc3c43d3e48f8c4956b191ab1">&#9670;&nbsp;</a></span>m2m_ota_start_update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_start_update </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>u8DownloadUrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request OTA start update using the downloaded URL. The firmware OTA module will download the OTA image, ensure integrity of the image, and update the validity of the image in the control structure. On completion, a callback of type <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> is called (callback previously provided via <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init()</a>). Switching to the updated image additionally requires completion of <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware()</a>, and system_reset().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u8DownloadUrl</td><td>The download firmware URL, according to the application server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Calling this API does not guarantee OTA WINC image update; it depends on the connection with the download server and the validity of the image. Calling this API invalidates the previous rollback image. The current image will become the rollback image after <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware()</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init()</a> must have been called before using <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gaefb92e6e53637bd62b8371e7f00dd4eb">m2m_ota_start_update()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init()</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware()</a> <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. Note that successful operation in this context means the OTA update request has reached the firmware OTA module. It does not indicate whether or not the image update succeeded.</dd></dl>
<h1><a class="anchor" id="OTAExample"></a>
Example</h1>
<p>This example shows how an OTA image update and switch is carried out. It demonstrates use of the following OTA APIs: <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init()</a> <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gaefb92e6e53637bd62b8371e7f00dd4eb">m2m_ota_start_update()</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware()</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback()</a> It also makes use of <a class="el" href="group___v_e_r_s_i_o_n_a_p_i.html#gaf649466de77518fe9eb35ed9a234bf32">m2m_wifi_check_ota_rb()</a> in order to inform OTA decisions.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> OtaUpdateCb(uint8_t u8OtaUpdateStatusType ,uint8_t u8OtaUpdateStatus)</div><div class="line">{</div><div class="line">    int8_t s8tmp;</div><div class="line">    <a class="code" href="structtstr_m2m_rev.html">tstrM2mRev</a> strtmp;</div><div class="line"></div><div class="line">    <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;%d %d\n&quot;</span>, u8OtaUpdateStatusType, u8OtaUpdateStatus);</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span>(u8OtaUpdateStatusType) {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#gga3e56744d263918b9e36016f78d823c3aa9b634fb58a53969f9af8a89908e58c5e">DL_STATUS</a>:</div><div class="line">            <span class="keywordflow">if</span>(u8OtaUpdateStatus == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#ggab7006b9cb55eb414d0416d0513533eeba23e293bcc679d3021e202ac255b71500">OTA_STATUS_SUCCESS</a>) {</div><div class="line">                <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;OTA download succeeded\n&quot;</span>);</div><div class="line">                s8tmp = <a class="code" href="group___v_e_r_s_i_o_n_a_p_i.html#gaf649466de77518fe9eb35ed9a234bf32">m2m_wifi_check_ota_rb</a>();</div><div class="line">                <span class="keywordflow">if</span>(s8tmp == <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga589113b133769b3e1ef49b515d85364c">M2M_ERR_FW_VER_MISMATCH</a>) {</div><div class="line">                    <span class="comment">//  In this case the application SHOULD update the host driver before calling</span></div><div class="line">                    <span class="comment">//  @ref m2m_ota_switch_firmware(). Switching firmware image and resetting without updating host</span></div><div class="line">                    <span class="comment">//  driver would lead to severely limited functionality (i.e. OTA rollback only).</span></div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(s8tmp == <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>) {</div><div class="line">                    <span class="comment">//  In this case the application MAY WANT TO update the host driver before calling</span></div><div class="line">                    <span class="comment">//  @ref m2m_ota_switch_firmware(). Switching firmware image and resetting without updating host</span></div><div class="line">                    <span class="comment">//  driver may lead to suboptimal functionality.</span></div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> {</div><div class="line">                    <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;Cannot recognize downloaded image\n&quot;</span>);</div><div class="line">                    <span class="comment">//  In this case the application MUST NOT update the host driver if such an update would change the</span></div><div class="line">                    <span class="comment">//  driver HIF Major field. Firmware switch @ref using m2m_ota_switch_firmware() is blocked.</span></div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">                <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;Now switching active partition...\n&quot;</span>);</div><div class="line">                s8tmp = <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>();</div><div class="line">            }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#gga3e56744d263918b9e36016f78d823c3aa2f1dabb326d861eadb5a5cd1b41962ff">SW_STATUS</a>:</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#gga3e56744d263918b9e36016f78d823c3aad9b2f16f8c41c4108806a4c78dea422c">RB_STATUS</a>:</div><div class="line">            <span class="keywordflow">if</span>(u8OtaUpdateStatus == <a class="code" href="group___o_t_a_t_y_p_e_d_e_f.html#ggab7006b9cb55eb414d0416d0513533eeba23e293bcc679d3021e202ac255b71500">OTA_STATUS_SUCCESS</a>) {</div><div class="line">                <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;Switch/Rollback succeeded\n&quot;</span>);</div><div class="line">                <a class="code" href="group___debug_defines.html#ga84108eca2655e811179386a39c62acf2">M2M_INFO</a>(<span class="stringliteral">&quot;Now resetting the system...\n&quot;</span>);</div><div class="line">                system_reset();</div><div class="line">            }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> wifi_event_cb(uint8_t u8WiFiEvent, <span class="keywordtype">void</span> * pvMsg)</div><div class="line">{</div><div class="line">    <span class="comment">//  ...</span></div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group___wlan_enums.html#gga064de09dec1d5e88ed8d075fa40f57deaa849449fa83e4b552689266a1f1019e7">M2M_WIFI_REQ_DHCP_CONF</a>:</div><div class="line">    {</div><div class="line">        <span class="comment">//After successful connection, start the OTA upgrade.</span></div><div class="line">        <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gaefb92e6e53637bd62b8371e7f00dd4eb">m2m_ota_start_update</a>(OTA_URL);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">    <span class="comment">//  ...</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    int8_t              ret = <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>;</div><div class="line">    <a class="code" href="structtstr_wifi_init_param.html">tstrWifiInitParam</a>   param;</div><div class="line">    <span class="keywordtype">bool</span>                rollback_required = FALSE;</div><div class="line"></div><div class="line">    <span class="comment">//  ... system init etc here ...</span></div><div class="line"></div><div class="line">    <span class="comment">//Initialize the WINC Driver.</span></div><div class="line">    memset((uint8_t*)&amp;param, 0, <span class="keyword">sizeof</span>(param));</div><div class="line">    param.pfAppWifiCb = wifi_event_cb;</div><div class="line"></div><div class="line">    ret = <a class="code" href="group___w_l_a_n_a_p_i.html#ga66f5bf5f84f898bdd4453f2717a3deb5">m2m_wifi_init</a>(&amp;param);</div><div class="line">    <span class="keywordflow">if</span>(ret == <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga589113b133769b3e1ef49b515d85364c">M2M_ERR_FW_VER_MISMATCH</a>) {</div><div class="line">        ret = <a class="code" href="group___v_e_r_s_i_o_n_a_p_i.html#gaf649466de77518fe9eb35ed9a234bf32">m2m_wifi_check_ota_rb</a>();</div><div class="line">        <span class="keywordflow">if</span>(ret == <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>) {</div><div class="line">            <span class="comment">//  In this case the image in the inactive partition has compatible HIF. We will switch/rollback to it</span></div><div class="line">            <span class="comment">//  after initializing the OTA module.</span></div><div class="line">            rollback_required = TRUE;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span>(ret != <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>) {</div><div class="line">        <a class="code" href="group___debug_defines.html#ga34d005df494e50b05cd38b80f318d7ac">M2M_ERR</a>(<span class="stringliteral">&quot;Driver Init Failed &lt;%d&gt;\n&quot;</span>,ret);</div><div class="line">        <span class="keywordflow">while</span>(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//Initialize the OTA module.</span></div><div class="line">    <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a>(OtaUpdateCb, NULL);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(rollback_required) {</div><div class="line">        <span class="comment">//  We need to call either @ref m2m_ota_rollback() or @ref m2m_ota_switch_firmware() (functionally equivalent).</span></div><div class="line">        <a class="code" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a>();</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">//  Connect to AP that provides connection to the OTA server</span></div><div class="line">        <a class="code" href="group___w_l_a_n_a_p_i.html#ga739abd39f7befa0da7bcea564a726141">m2m_wifi_default_connect</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(1) {</div><div class="line">        <span class="comment">//  Handle the app state machine plus the WINC event handler.</span></div><div class="line">        <span class="keywordflow">while</span>(<a class="code" href="group___w_l_a_n_a_p_i.html#ga4f0db0a89400730ce569aa9e13a3108b">m2m_wifi_handle_events</a>(NULL) != <a class="code" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a>) {</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga24e44fbce7ca42ded0e1daa500c40ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24e44fbce7ca42ded0e1daa500c40ca8">&#9670;&nbsp;</a></span>m2m_ota_switch_firmware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t m2m_ota_switch_firmware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to the upgraded Firmware. </p>
<p>Request switch to the updated WINC image. The WINC firmware will check the validity of the inactive image and activate it if it is valid. On completion, a callback of type <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> is called (application must previously have provided the callback via <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init</a>). If the callback indicates successful activation, the newly-activated image will start running after next system reset.</p>
<dl class="section return"><dt>Returns</dt><dd>The function SHALL return 0 for success and a negative value otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If switch will necessitate a host driver update in order to maintain HIF compatibility (HIF major value change), then it is recommended to update the host driver prior to calling this API.<br />
 In the event of system reset with incompatible driver/firmware, compatibility can be recovered by calling <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a> or <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga80058af2f37ab262dbc1b5f5327708f7" title="Initialize the OTA layer.">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise.</dd>
<dd>
The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for success and a negative value otherwise.</dd></dl>
<p>Request switch to the updated WINC image. The WINC firmware will check the validity of the inactive image and activate it if it is valid. On completion, a callback of type <a class="el" href="group___o_t_a_c_a_l_l_b_a_c_k_s.html#gaa6260f28a072a2bc1e6dad0d75659c3a">tpfOtaUpdateCb</a> is called (application must previously have provided the callback via <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga08275ebf9834c5223311bc8ae9627959">m2m_ota_init()</a>). If the callback indicates successful activation, the newly-activated image will start running after next system reset.</p>
<dl class="section warning"><dt>Warning</dt><dd>If switch will necessitate a host driver update in order to maintain HIF compatibility (HIF major value change), then it is recommended to update the host driver prior to calling this API. In the event of system reset with incompatible driver/firmware, compatibility can be recovered by calling <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#gad238a0b0d9218b8db10d82a95fc91dad">m2m_ota_rollback</a> or <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga24e44fbce7ca42ded0e1daa500c40ca8">m2m_ota_switch_firmware</a>. See <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#OTAExample">Example</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga80058af2f37ab262dbc1b5f5327708f7" title="Initialize the OTA layer.">m2m_ota_init</a> <a class="el" href="group___o_t_a_f_u_n_c_t_i_o_n_s.html#ga38a82b1bc3c43d3e48f8c4956b191ab1">m2m_ota_start_update</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns <a class="el" href="group___c_o_m_m_o_n_d_e_f.html#ga9ef27ba27aafdd1aa3a79d3ba2c36b8f">M2M_SUCCESS</a> for successful operations and a negative value otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
  <span class="stringliteral">  2019 Microchip Technology Inc. </span>
</body>
</html>
